Self-Hosted Authentication Options: For user authentication and authorization, we considered using a dedicated auth service. Two popular self-hostable solutions are Supabase Auth and Keycloak, and we also weighed a custom JWT-based approach. Supabase Auth is part of the Supabase platform (an open-source Firebase alternative) which provides easy email/password and social logins out-of-the-box, tightly integrated with a Postgres database (it even uses Postgres row-level security for access control) ￼ ￼. It’s lightweight and developer-friendly, but it’s somewhat tied to Supabase’s ecosystem and is relatively new. Keycloak, on the other hand, is a mature open-source identity and access management solution. It supports enterprise features like single sign-on (SSO), identity brokering (social logins and external LDAP/AD integration), and it implements standard protocols (OAuth2, OpenID Connect, SAML) ￼. Keycloak offers fine-grained roles and policies and would be a robust choice if we needed enterprise-level auth or have multiple client applications. However, Keycloak is heavier to deploy and manage (requires its own server and database) and can be overkill for a small app initially.

A fully custom JWT-based approach means implementing our own user database (which we have) and using Node libraries to handle password hashing, issuing JWT tokens, and refreshing them. This gives us complete control and can be lightweight, but we’d need to handle many security aspects (password resets, email verification, 2FA if needed, etc.) ourselves over time.

We decided to start with a simple JWT auth implementation for rapid prototyping, with the plan to remain flexible for future migration. Starting with our own JWT auth means we can get the system working without introducing external complexity. We will design the auth module such that moving to Supabase Auth or Keycloak later would not require a complete overhaul. For example, we will follow OAuth2 concepts even in our JWT system (issuing access and refresh tokens, using standardized claims), so that if we swap in Keycloak later, the front-end communication (which expects an access token, refresh flow) can remain largely unchanged.

Initial Implementation (JWT for prototyping): In the initial version, the Autolink API itself will handle authentication via JWTs. We will create an /api/auth/login endpoint where users send their email/username and password. The API will verify the credentials against the Users table (passwords stored as salted bcrypt hashes) and, if valid, issue a JWT access token signed with our server’s secret. The token will include the user’s ID and role in its payload (and possibly some basic profile info like name for convenience, though nothing sensitive). We will also issue a refresh token – either as a longer-lived JWT or a random token stored server-side – to allow the client to obtain new access tokens without re-entering credentials. The access token lifetime will be kept short (e.g. 15 minutes or 1 hour) for security ￼, since shorter-lived tokens reduce risk if stolen. The refresh token will have a longer lifespan (perhaps 7 days or 30 days) and will be stored securely (http-only cookie on web, secure storage on mobile). Using refresh tokens means we can invalidate sessions (e.g. on password change or logout) by blacklisting refresh tokens server-side or rotating secrets.

The JWT signing will use a strong algorithm (HS256 or RS256). In the future, if we transition to Keycloak, we would instead validate tokens against Keycloak’s public keys (which is a compatible change since Keycloak also uses JWTs for OAuth tokens).

Migration Path: To keep migration easy, our plan is to abstract the auth logic. For instance, we’ll implement token verification as middleware that could be swapped out. If we move to Keycloak, instead of our JWT verification, we’d use Keycloak’s JSON Web Key Set (JWKS) to validate tokens. Similarly, if we moved to Supabase Auth, we might use Supabase’s provided auth endpoints and just trust the JWTs it issues (Supabase’s JWT would include the same user IDs since it’s integrated with Postgres). Because we are following standard practices (OAuth2-like bearer tokens), the front-end is already treating the auth in a standard way (saving tokens, adding Authorization: Bearer <token> headers). So switching the underlying provider should not affect the app’s behavior beyond the login flow.

User Management Features: Our auth solution includes basic user management functionalities. We support secure user registration (with email verification as a future addition), login, and logout. Passwords are never stored in plain text – we hash them (with bcrypt or argon2) so that even if the database were compromised, original passwords are not exposed. We enforce password complexity rules to some extent and may add breach password checking in the future.

The JWT tokens we issue will be configured to expire (the exp claim) as discussed, and the front-end will proactively refresh the token before expiry using the refresh token. If a refresh token is stolen or a user needs to be logged out remotely, we have the ability to revoke tokens. One strategy is to keep a token blacklist or maintain a token version in the user record that must match (i.e., if we increment a user’s token version on password reset, existing tokens become invalid). This adds a bit of complexity but is doable. For initial simplicity, we might not implement full token revocation aside from honor system (user logout deletes refresh token on client and server doesn’t keep long-term session state). But since refresh tokens are long-lived, we plan to store them hashed in a server-side store (or in the database) so that logout or manual revocation is possible (this is similar to how Supabase manages revoking refresh tokens or how Keycloak manages sessions).

We also ensure the system is ready for role-based access control as mentioned. The user’s role (e.g., “user”, “admin”) is embedded in JWT claims, and the API uses it to authorize endpoints. If we later integrate Keycloak, we can map Keycloak roles to our app roles to maintain continuity.

In the future, we can consider adding OAuth2 social logins (Google, Facebook login) to improve user convenience. With our current approach, this would mean integrating with those providers and still issuing our JWTs upon successful third-party auth. If we were using Keycloak or Supabase, they have built-in support for social OAuth, which is a point in their favor if that becomes a priority.

For now, the authentication service (even if part of our main API) is kept separate logically: we treat it as an Auth module which could be replaced by an external service. This gives us the benefit of a prototype-friendly solution (fast to implement) while keeping the door open for a more robust auth system (like Keycloak’s fine-grained policies or Supabase’s ease of use) when the project grows or requires enterprise features.