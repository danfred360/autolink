Framework (React Native with Expo): The Autolink mobile app is built with React Native and uses Expo to target iOS, Android, and web from a single codebase. This cross-platform approach allows us to develop features once and deploy them across platforms, which speeds up development and ensures consistency ￼. Expo provides a managed framework that streamlines building, testing, and deploying the app with minimal native configuration ￼. This keeps the client lightweight while still enabling use of native device features via Expo’s SDK.

State Management: We evaluated several state management libraries – Redux, Recoil, Zustand, and the React Context API – based on performance, maintainability, and scalability. Redux offers a predictable centralized store and robust DevTools, making it suitable for complex, large-scale apps, but it requires significant boilerplate code ￼. Recoil and Zustand are more lightweight and easier to integrate, providing better localized performance with less boilerplate; Recoil is newer (Facebook-developed) and supports fine-grained atomic state, while Zustand is minimalistic and avoids unnecessary re-renders for high performance ￼. The Context API is built-in and fine for small amounts of global state, but it can lead to performance issues if overused (updates re-render all consumers) ￼. Key takeaway: Redux remains best for very large apps with complex state, whereas Recoil or Zustand can offer simpler and faster state management for medium-sized projects, and Context is only viable for limited global state ￼. For Autolink, which should stay lightweight, we favor a minimal state solution (like Zustand or Recoil) to start, ensuring easy refactoring if the app’s complexity grows. This is why we will use Recoil.

Design Principles: We adhere to modular design and separation of concerns to keep the front-end maintainable and extensible. UI components are kept presentational and reusable, while stateful logic (API calls, form handling) is moved to hooks or controller components. This modular approach makes it easier to add features without touching unrelated parts of the app. We strive to keep the bundle size small by avoiding heavy libraries unless necessary, aligning with the “learn once, write anywhere” React Native philosophy. Code is organized by feature (each feature having its own screens, components, and state logic) to localize changes and make future expansion easier. We also follow best practices like using TypeScript for type safety and leveraging Expo’s updates to stay current with minimal effort. Overall, the front-end is designed to remain lightweight, responsive, and easy to maintain, so new features (like trip logging, expense tracking, etc.) can be added with minimal refactoring.